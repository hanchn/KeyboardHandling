# 硬件操作的权限模型与限制（浏览器 vs 桌面应用）


### —— 浏览器 vs 桌面应用（Electron / Node.js）

---

### 🧠 一、为什么“权限模型”是操作硬件的首要问题？

操作硬件 = 操作系统资源 + 用户隐私行为。
因此在浏览器或桌面端，**操作硬件**的第一道门槛就是 **“权限控制”**，不合规或无授权的代码将**无法访问**或只能访问**受限的数据流**。

---

### 🌐 二、浏览器端的权限模型与限制

#### ✅ 可访问的硬件（前提：用户授权 + HTTPS + 支持浏览器）：

| 功能         | 对应 API                | 权限方式   | 说明               |
| ---------- | --------------------- | ------ | ---------------- |
| 摄像头 / 麦克风  | `getUserMedia()`      | 弹窗授权   | 视频流/音频流，无法直接保存   |
| 打印         | `window.print()`      | 无需权限   | 调用系统打印 UI，无法控制细节 |
| 条码扫描（扫码枪）  | 模拟键盘输入                | 无需权限   | 只要聚焦在输入框即可       |
| 文件读写       | `File` / `FileReader` | 用户手动选择 | 无法写入磁盘           |
| HID设备（如手柄） | `WebHID API`          | 授权后使用  | 支持度较低，Chrome原生支持 |
| 蓝牙设备       | `WebBluetooth`        | 授权后使用  | 限 HTTPS，权限严格     |
| 串口设备       | `WebSerial`           | 授权后使用  | 必须在用户触发事件中调用     |
| USB设备      | `WebUSB`              | 授权后使用  | 支持设备有限且较复杂       |

#### ❌ 无法访问的硬件或功能：

* 无法直接读取磁盘目录（如 C 盘、桌面）
* 无法调用打印机驱动（打印位置、双面设置）
* 无法在后台监听设备插拔
* 无法写入本地硬件或安装驱动

#### ⚠️ 注意点

* 所有操作必须在 HTTPS 环境中进行（localhost 特例可用）
* 用户必须进行“主动行为”（click）才能请求授权
* 兼容性存在问题（如 Safari 不支持 WebUSB / WebHID）

---

### 💻 三、桌面应用（Electron / Node.js）的权限与自由度

#### ✅ 可完全控制硬件（只要有系统权限）：

| 操作场景      | 使用模块                  | 说明               |
| --------- | --------------------- | ---------------- |
| 读取 USB 设备 | `node-usb`            | 枚举、监听插拔、发送指令     |
| 连接串口设备    | `serialport`          | 控制 LED、扫码器、热敏机   |
| 打印控制      | `printer`             | 自定义纸张、自动打印、监听状态  |
| 调用摄像头     | `node-webcam`         | 保存照片、图像识别        |
| 调用操作系统功能  | `fs`, `child_process` | 可写入磁盘、执行脚本、打开文件等 |
| HID设备识别   | `node-hid`            | 控制手柄、刷卡器等        |

#### 🔐 安全与权限处理方式：

* 桌面应用默认拥有所有本地权限（管理员模式更强）
* 通过 `Electron` 可内嵌 Node.js，前端+后端合一
* 可以通过沙盒或白名单方式限制某些操作（如只允许识别指定设备）

#### ⚠️ 注意点

* Windows 下操作某些设备需要**管理员权限**
* 使用驱动级调用需匹配设备厂商驱动或协议文档
* Electron 打包需注意安全风险（如避免 XSS 导致远程代码注入）

---

### 🤔 四、对比总结：浏览器 vs 桌面端权限能力表

| 功能         | 浏览器（Web API） | 桌面端（Electron + Node.js） |
| ---------- | ------------ | ----------------------- |
| 摄像头调用      | ✅ 限权限        | ✅ 更自由，可存图               |
| 条码枪输入      | ✅ 模拟键盘       | ✅ 串口可识别型号               |
| 自定义打印      | ❌ 不支持驱动      | ✅ 精确控制纸张/方向             |
| 磁盘访问       | ❌ 仅选择文件      | ✅ 可任意读写                 |
| USB/HID/蓝牙 | ✅（部分API）     | ✅ 支持所有协议设备              |
| 后台运行       | ❌ 标签页关闭失效    | ✅ 可监听插拔/守护运行            |

---

### 🛠️ 五、案例对比：扫码枪接入

#### 浏览器端接入方式：

```js
document.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    console.log('扫码完成：', buffer);
    buffer = '';
  } else {
    buffer += e.key;
  }
});
```

**限制：** 无法识别扫码枪型号，只能靠“模拟输入”方式处理。

#### 桌面端接入方式（Node.js 串口）：

```js
const SerialPort = require('serialport');
const port = new SerialPort('/dev/ttyUSB0', { baudRate: 9600 });

port.on('data', function(data) {
  console.log('扫码内容：', data.toString());
});
```

**优势：** 能读取任意设备的原始数据，适配更多场景如医疗扫码器、仓库PDA设备。

---

### ✅ 小结

| 场景           | 推荐方式       | 原因            |
| ------------ | ---------- | ------------- |
| 快速开发 / 部署广泛  | 浏览器        | 用户易访问、无安装     |
| 高度控制 / 多硬件对接 | 桌面端        | 权限更高、控制能力强    |
| 长期项目 / 商用部署  | 桌面端 + 前端组件 | 用户体验 + 硬件能力兼顾 |

---
